/*******************************************************************************
 * @File: btn.c
 * @Author: Milandr, L.
 * @Project: Sample 2.3
 * @Microcontroller: 1986VE92U
 * @Device: Evaluation Board For MCU 1986VE92U
 * @Date: 05.04.2017
 * @Purpose: Обработка сигналов с механических кнопок
 *******************************************************************************/

// Подключение заголовочного файла
#include "btn.h"

// Инициализация портов для работы с кнопками
void BTN_Init(void)
{
  // Включение тактирования портов B, C и E
  MDR_RST_CLK->PER_CLOCK |= (1 << RST_CLK_PCLK_PORTB_Pos)   // Порт B
                          | (1 << RST_CLK_PCLK_PORTC_Pos)   // Порт C
                          | (1 << RST_CLK_PCLK_PORTE_Pos);  // Порт E

  // Конфигурация линии PB5 (кнопка UP)
  MDR_PORTB->OE     &= ~(1 << 5);   // Направление данных (ввод)
  MDR_PORTB->FUNC   &= ~(3 << 10);  // Функция линии (ввод-вывод)
  MDR_PORTB->ANALOG |=  (1 << 5);   // Режим работы линии (цифровой)
  MDR_PORTB->PULL   &= ~(1 << 5);   // Подтяжка к земле (отключена)
  MDR_PORTB->PULL   &= ~(1 << 21);  // Подтяжка к питанию (отключена)
  MDR_PORTB->PD     &= ~(1 << 5);   // Управление линией (не используется)
  MDR_PORTB->PD     &= ~(1 << 21);  // Триггер Шмитта (отключен)
  MDR_PORTB->PWR    &= ~(3 << 10);  // Cброс битов регистра PWR
  MDR_PORTB->PWR    |=  (1 << 10);  // Крутизна фронтов (низкая)
  MDR_PORTB->GFEN   &= ~(1 << 5);   // Цифровой фильтр (отключен)

  // Конфигурация линии PC2 (кнопка SEL)
  MDR_PORTC->OE     &= ~(1 << 2);   // Направление данных (ввод)
  MDR_PORTC->FUNC   &= ~(3 << 4);   // Функция линии (ввод-вывод)
  MDR_PORTC->ANALOG |=  (1 << 2);   // Режим работы линии (цифровой)
  MDR_PORTC->PULL   &= ~(1 << 2);   // Подтяжка к земле (отключена)
  MDR_PORTC->PULL   &= ~(1 << 18);  // Подтяжка к питанию (отключена)
  MDR_PORTC->PD     &= ~(1 << 2);   // Управление линией (не используется)
  MDR_PORTC->PD     &= ~(1 << 18);  // Триггер Шмитта (отключен)
  MDR_PORTC->PWR    &= ~(3 << 4);   // Cброс битов регистра PWR
  MDR_PORTC->PWR    |=  (1 << 4);   // Крутизна фронтов (низкая)
  MDR_PORTC->GFEN   &= ~(1 << 2);   // Цифровой фильтр (отключен)

  // Конфигурация линии PE1 (кнопка DOWN)
  MDR_PORTE->OE     &= ~(1 << 1);   // Направление данных (ввод)
  MDR_PORTE->FUNC   &= ~(3 << 2);   // Функция линии (ввод-вывод)
  MDR_PORTE->ANALOG |=  (1 << 1);   // Режим работы линии (цифровой)
  MDR_PORTE->PULL   &= ~(1 << 1);   // Подтяжка к земле (отключена)
  MDR_PORTE->PULL   &= ~(1 << 17);  // Подтяжка к питанию (отключена)
  MDR_PORTE->PD     &= ~(1 << 1);   // Управление линией (не используется)
  MDR_PORTE->PD     &= ~(1 << 17);  // Триггер Шмитта (отключен)
  MDR_PORTE->PWR    &= ~(3 << 2);   // Cброс битов регистра PWR
  MDR_PORTE->PWR    |=  (1 << 2);   // Крутизна фронтов (низкая)
  MDR_PORTE->GFEN   &= ~(1 << 1);   // Цифровой фильтр (отключен)
}

// Поток опроса кнопки DOWN
void Thread_DownButtonCheck(void *argument)
{
  // Цикл проверки
  while (1)
  {
    // Проверка нажатия
    if ((MDR_PORTE->RXTX & (1 << 1)) == 0)
    {
      // Задержка для защиты от дребезга контактов
      osDelay(10);

      // Подтверждение нажатия
      if ((MDR_PORTE->RXTX & (1 << 1)) == 0)
      {
        // Изменение состояния системы
        current_state++;

        // Проверка на выход из диапазона определенных состояний
        if (current_state > BLUE) 
          current_state = RED;

        // Реализация текущего состояния
        LCD_ImplementState(current_state);

        // Ожидание отпускания
        while ((MDR_PORTE->RXTX & (1 << 1)) == 0)
          osDelay(25);
      }
    }

    // Задержка перед началом следующей проверки
    osDelay(25);
  }
}

// Поток опроса кнопки UP
void Thread_UpButtonCheck(void *argument)
{
  // Цикл проверки
  while (1)
  {
    // Проверка нажатия
    if ((MDR_PORTB->RXTX & (1 << 5)) == 0)
    {
      // Задержка для защиты от дребезга контактов
      osDelay(10);

      // Подтверждение нажатия
      if ((MDR_PORTB->RXTX & (1 << 5)) == 0)
      {
        // Изменение состояния системы
        current_state--;

        // Проверка на выход из диапазона определенных состояний
        if (current_state < RED)
          current_state = BLUE;

        // Реализация текущего состояния
        LCD_ImplementState(current_state);

        // Ожидание отпускания
        while ((MDR_PORTB->RXTX & (1 << 5)) == 0)
          osDelay(25);
      }
    }

    // Задержка перед началом следующей проверки
    osDelay(25);
  }
}

// Поток опроса кнопки SEL
void Thread_SelectButtonCheck(void *argument)
{
  // Цикл проверки
  while (1)
  {
    // Проверка нажатия
    if ((MDR_PORTC->RXTX & (1 << 2)) == 0)
    {
      // Задержка для защиты от дребезга контактов
      osDelay(10);

      // Подтверждение нажатия
      if ((MDR_PORTC->RXTX & (1 << 2)) == 0)
      {
        // Инверсия выбранного светодиода
        switch (current_state)
        {
          // Состояние "RED"
          case RED:
            // Инверсия состояния красного светодиода
            MDR_PORTB->RXTX ^= (1 << 0);
            break;

          // Состояние "YELLOW"
          case YELLOW:
            // Инверсия состояния желтого светодиода
            MDR_PORTB->RXTX ^= (1 << 1);
            break;

          // Состояние "GREEN"
          case GREEN:
            // Инверсия состояния зеленого светодиода
            MDR_PORTB->RXTX ^= (1 << 2);
            break;

          // Состояние "BLUE"
          case BLUE:
            // Инверсия состояния синего светодиода
            MDR_PORTB->RXTX ^= (1 << 3);
            break;

          // Неопределенное состояние
          default:
            // Переход в состояние "RED"
            current_state = RED;
            break;
        }

        // Ожидание отпускания
        while ((MDR_PORTC->RXTX & (1 << 2)) == 0)
          osDelay(25);
      }

      // Задержка перед началом следующей проверки
      osDelay(25);
    }
  }
}
