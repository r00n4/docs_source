/*******************************************************************************
 * @File: btn.c
 * @Author: Milandr, L.
 * @Project: Sample 2.3
 * @Microcontroller: 1986VE92U
 * @Device: Evaluation Board For MCU 1986VE92U
 * @Date: 04.04.2017
 * @Purpose: Обработка сигналов с механических кнопок
 *******************************************************************************/

// Подключение заголовочного файла
#include "btn.h"

// Инициализация портов для работы с кнопками
void BTN_Init(void)
{
  // Включение тактирования портов B и E
  MDR_RST_CLK->PER_CLOCK |= (1 << RST_CLK_PCLK_PORTB_Pos)   // Порт B
                          | (1 << RST_CLK_PCLK_PORTE_Pos);  // Порт E

  // Конфигурация линии PB5 (кнопка UP)
  MDR_PORTB->OE     &= ~(1 << 5);   // Направление данных (ввод)
  MDR_PORTB->FUNC   &= ~(3 << 10);  // Функция линии (ввод-вывод)
  MDR_PORTB->ANALOG |=  (1 << 5);   // Режим работы линии (цифровой)
  MDR_PORTB->PULL   &= ~(1 << 5);   // Подтяжка к земле (отключена)
  MDR_PORTB->PULL   &= ~(1 << 21);  // Подтяжка к питанию (отключена)
  MDR_PORTB->PD     &= ~(1 << 5);   // Управление линией (не используется)
  MDR_PORTB->PD     &= ~(1 << 21);  // Триггер Шмитта (отключен)
  MDR_PORTB->PWR    &= ~(3 << 10);  // Cброс битов регистра PWR
  MDR_PORTB->PWR    |=  (1 << 10);  // Крутизна фронтов (низкая)
  MDR_PORTB->GFEN   &= ~(1 << 5);   // Цифровой фильтр (отключен)

  // Конфигурация линии PE1 (кнопка DOWN)
  MDR_PORTE->OE     &= ~(1 << 1);   // Направление данных (ввод)
  MDR_PORTE->FUNC   &= ~(3 << 2);   // Функция линии (ввод-вывод)
  MDR_PORTE->ANALOG |=  (1 << 1);   // Режим работы линии (цифровой)
  MDR_PORTE->PULL   &= ~(1 << 1);   // Подтяжка к земле (отключена)
  MDR_PORTE->PULL   &= ~(1 << 17);  // Подтяжка к питанию (отключена)
  MDR_PORTE->PD     &= ~(1 << 1);   // Управление линией (не используется)
  MDR_PORTE->PD     &= ~(1 << 17);  // Триггер Шмитта (отключен)
  MDR_PORTE->PWR    &= ~(3 << 2);   // Cброс битов регистра PWR
  MDR_PORTE->PWR    |=  (1 << 2);   // Крутизна фронтов (низкая)
  MDR_PORTE->GFEN   &= ~(1 << 1);   // Цифровой фильтр (отключен)
}

// Поток опроса кнопки DOWN
void Thread_DownButtonCheck(void *argument)
{
  // Цикл проверки
  while (1)
  {
    // Проверка нажатия
    if ((MDR_PORTE->RXTX & (1 << 1)) == 0)
    {
      // Задержка для защиты от дребезга контактов
      osDelay(10);

      // Подтверждение нажатия
      if ((MDR_PORTE->RXTX & (1 << 1)) == 0)
      {
        // Уменьшение коэффициента заполнения на величину шага
        duty_cycle -= DUTY_CYCLE_DELTA;

        // Проверка на выход из допустимого диапазона значений
        if (duty_cycle < 0) 
          duty_cycle = 0;

        // Реализация нового коэффициента заполнения
        PWM_SetDutyCycle(duty_cycle);

        // Ожидание отпускания
        while ((MDR_PORTE->RXTX & (1 << 1)) == 0)
          osDelay(25);
      }
    }

    // Задержка перед началом следующей проверки
    osDelay(25);
  }
}

// Поток опроса кнопки UP
void Thread_UpButtonCheck(void *argument)
{
  // Цикл проверки
  while (1)
  {
    // Проверка нажатия
    if ((MDR_PORTB->RXTX & (1 << 5)) == 0)
    {
      // Задержка для защиты от дребезга контактов
      osDelay(10);

      // Подтверждение нажатия
      if ((MDR_PORTB->RXTX & (1 << 5)) == 0)
      {
        // Увеличение коэффициента заполнения на величину шага
        duty_cycle += DUTY_CYCLE_DELTA;

        // Проверка на выход из допустимого диапазона значений
        if (duty_cycle > 100)
          duty_cycle = 100;

        // Реализация нового коэффициента заполнения
        PWM_SetDutyCycle(duty_cycle);

        // Ожидание отпускания
        while ((MDR_PORTB->RXTX & (1 << 5)) == 0)
          osDelay(25);
      }
    }

    // Задержка перед началом следующей проверки
    osDelay(25);
  }
}
