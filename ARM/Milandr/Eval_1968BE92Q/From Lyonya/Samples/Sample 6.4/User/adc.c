/*******************************************************************************
 * @File: adc.c
 * @Author: Milandr, L.
 * @Project: Sample 6.4
 * @Microcontroller: 1986VE92U
 * @Device: Evaluation Board For MCU 1986VE92U
 * @Date: 18.07.2018
 * @Purpose: Управление аналого-цифровым преобразователем
 *******************************************************************************/

// Подключение заголовочного файла
#include "adc.h"

// Буфер для хранения результатов преобразования
volatile uint32_t sample[ADC_SAMPLE_SIZE];

// Деинициализация аналого-цифровых преобразователей
void ADC_Reset(void)
{
  // Деинициализация первого АЦП
  MDR_ADC->ADC1_CFG     = 0;
  MDR_ADC->ADC1_H_LEVEL = 0;
  MDR_ADC->ADC1_L_LEVEL = 0;
  MDR_ADC->ADC1_RESULT;
  MDR_ADC->ADC1_STATUS  = 0;
  MDR_ADC->ADC1_CHSEL   = 0;

  // Деинициализация второго АЦП
  MDR_ADC->ADC2_CFG     = 0;
  MDR_ADC->ADC2_H_LEVEL = 0;
  MDR_ADC->ADC2_L_LEVEL = 0;
  MDR_ADC->ADC2_RESULT;
  MDR_ADC->ADC2_STATUS  = 0;
  MDR_ADC->ADC2_CHSEL   = 0;
}

// Конфигурация порта для работы АЦП
void ADC_PortCfg(void)
{
  // Включение тактирования требуемых порта D
  MDR_RST_CLK->PER_CLOCK |= (1 << RST_CLK_PCLK_PORTD_Pos);

  // Конфигурация линии PD5 и PD6
  MDR_PORTD->OE     &= ~((1 << 5)  | (1 << 6));
  MDR_PORTD->FUNC   &= ~((3 << 10) | (3 << 12));
  MDR_PORTD->ANALOG &= ~((1 << 5)  | (1 << 6));   // Режим работы линии (аналоговый)
  MDR_PORTD->PULL   &= ~((1 << 5)  | (1 << 6));   // Резистор подтяжки к цепи питания (отключен)
  MDR_PORTD->PULL   &= ~((1 << 21) | (1 << 22));  // Резистор подтяжки к земле (отключен)
  MDR_PORTD->PD     &= ~((1 << 5)  | (1 << 6));
  MDR_PORTD->PD     &= ~((1 << 21) | (1 << 22));
  MDR_PORTD->PWR    &= ~((3 << 10) | (3 << 12));
  MDR_PORTD->GFEN   &= ~((1 << 5)  | (1 << 6));
}

// Инициализация аналого-цифрового преобразователя
void ADC_Init(void)
{
  // Включение тактирования АЦП
  MDR_RST_CLK->PER_CLOCK |= (1 << RST_CLK_PCLK_ADC_Pos);

  // Деинициализация АЦП
  ADC_Reset();

  // Конфигурация порта для работы АЦП
  ADC_PortCfg();

  // Конфигурация АЦП
  MDR_ADC->ADC1_CFG = (1 << ADC1_CFG_REG_ADON_Pos)     // Работа АЦП (включен)
                    | (0 << ADC1_CFG_REG_CLKS_Pos)     // Источник тактирования АЦП (CPU)
                    | (1 << ADC1_CFG_REG_SAMPLE_Pos)   // Способ запуска АЦП (циклический)
                    | (0 << ADC1_CFG_REG_CHS_Pos)      // Целевой канал преобразователя (не указывается)
                    | (1 << ADC1_CFG_REG_CHCH_Pos)     // Режим последовательного переключения каналов (включен)
                    | (0 << ADC1_CFG_REG_RNGC_Pos)     // Контроль границ преобразования (отключен)
                    | (0 << ADC1_CFG_M_REF_Pos)        // Источник опорного напряжения (внутренний)
                    | (3 << ADC1_CFG_REG_DIVCLK_Pos)   // Делитель тактовой частоты АЦП (2^3 = 8)
                    | (0 << ADC1_CFG_SYNC_CONVER_Pos)  // Режим запуска двух АЦП (независимый)

  // ...Конфигурация датчика температуры и внутреннего источника напряжения 1.23 В
                    | (0 << ADC1_CFG_TS_EN_Pos)        // Работа блока датчика температуры и внутреннего источника напряжения 1.23 В (отключен)
                    | (0 << ADC1_CFG_TS_BUF_EN_Pos)    // Работа усилителя для датчика температуры и внутреннего источника напряжения 1.23 В (отключен)
                    | (0 << ADC1_CFG_SEL_TS_Pos)       // Преобразование сигнала с датчика температуры (включено)
                    | (0 << ADC1_CFG_SEL_VREF_Pos)     // Преобразование сигнала с внутреннего источника напряжения 1.23 В (отключено)
                    | (0 << ADC1_CFG_TR_Pos)           // Подстройка напряжения внутреннего источника 1.23 В

  // ...Настройка задержек при преобразовании
                    | (0 << ADC1_CFG_DELAY_GO_Pos)     // Дополнительная задержка при выборе канала для заряда внутренней емкости (1 такт ядра)
                    | (0 << ADC1_CFG_DELAY_ADC_Pos);   // Разность фаз между циклами преобразователей (не используется)

  // Выбор каналов для режима автоматического переключения
  MDR_ADC->ADC1_CHSEL = (1 << 5)   // Канал потенциометра RX
                      | (1 << 6);  // Канал потенциометра RY

  // Ожидание завершения первого преобразования
  // (результат этого преобразования будет использован в качестве зерна псевдослучайной последовательности)
  while ((MDR_ADC->ADC1_STATUS & ADC_STATUS_FLG_REG_EOCIF) == 0);

  // Отключение аналого-цифрового преобразователя
  MDR_ADC->ADC1_CFG &= ~(1 << ADC1_CFG_REG_ADON_Pos);
}

// Поток аналого-цифровых преобразований
void Thread_ADC(void *argument)
{
  uint32_t digitX, digitY;    // Значения преобразований по каналам потенциометров
  uint16_t amountX, amountY;  // Количество преобразований по каналу потенциометра RX
  uint32_t i;

  // Основной цикл
  while (1)
  {
    // Включение аналого-цифрового преобразователя
    MDR_ADC->ADC1_CFG |= (1 << ADC1_CFG_REG_ADON_Pos);

    // Ожидание окончания цикла аналого-ц ифровых преобразований
    osEventFlagsWait(EventId_ADC, EVENT_ADC_EOC, osFlagsWaitAny, osWaitForever);

    // Сложение элементов выборки преобразования
    for (i = 0, digitX  = 0, digitY  = 0,
                amountX = 0, amountY = 0;
         i < ADC_SAMPLE_SIZE; i++)
    {
      // Определение канала, по которому выполнение преобразование
      switch ((sample[i] & ADC_RESULT_CHANNEL_Msk) >> ADC_RESULT_CHANNEL_Pos)
      {
        // Канал напряжения
        case 5:
          digitX += sample[i] & ADC_RESULT_Msk;
          amountX++;
          break;

        // Канал измерения температуры
        case 6:
          digitY += sample[i] & ADC_RESULT_Msk;
          amountY++;
          break;
      }
    }

    // Усреднение результатов
    if (amountX)
      digitX /= amountX;

    if (amountY)
      digitY /= amountY;

    // Передвижение указателя на дисплее
    DOG_MoveCursor(digitX, digitY);

    // Задержка перед началом следующей итерации
    osDelay(100);
  }
}
