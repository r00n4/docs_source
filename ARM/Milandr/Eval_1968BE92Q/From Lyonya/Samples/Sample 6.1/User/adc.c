/*******************************************************************************
 * @File: adc.c
 * @Author: Milandr, L.
 * @Project: Sample 6.1
 * @Microcontroller: 1986VE92U
 * @Device: Evaluation Board For MCU 1986VE92U
 * @Date: 24.03.2017
 * @Purpose: Управление аналого-цифровым преобразователем
 *******************************************************************************/

// Подключение заголовочного файла
#include "adc.h"

// Деинициализация аналого-цифровых преобразователей
void ADC_Reset(void)
{
  // Деинициализация первого АЦП
  MDR_ADC->ADC1_CFG     = 0;
  MDR_ADC->ADC1_H_LEVEL = 0;
  MDR_ADC->ADC1_L_LEVEL = 0;
  MDR_ADC->ADC1_RESULT;
  MDR_ADC->ADC1_STATUS  = 0;
  MDR_ADC->ADC1_CHSEL   = 0;

  // Деинициализация второго АЦП
  MDR_ADC->ADC2_CFG     = 0;
  MDR_ADC->ADC2_H_LEVEL = 0;
  MDR_ADC->ADC2_L_LEVEL = 0;
  MDR_ADC->ADC2_RESULT;
  MDR_ADC->ADC2_STATUS  = 0;
  MDR_ADC->ADC2_CHSEL   = 0;
}

// Конфигурация порта для работы АЦП
void ADC_PortCfg(void)
{
  // Включение тактирования требуемых порта D
  MDR_RST_CLK->PER_CLOCK |= (1 << RST_CLK_PCLK_PORTD_Pos);

  // Конфигурация линии PD5
  MDR_PORTD->OE     &= ~(1 << 5);
  MDR_PORTD->FUNC   &= ~(3 << 10);
  MDR_PORTD->ANALOG &= ~(1 << 5);   // Режим работы линии (аналоговый)
  MDR_PORTD->PULL   &= ~(1 << 5);   // Резистор подтяжки к цепи питания (отключен)
  MDR_PORTD->PULL   &= ~(1 << 21);  // Резистор подтяжки к земле (отключен)
  MDR_PORTD->PD     &= ~(1 << 5);
  MDR_PORTD->PD     &= ~(1 << 21);
  MDR_PORTD->PWR    &= ~(3 << 10);
  MDR_PORTD->GFEN   &= ~(1 << 5);
}

// Инициализация аналого-цифрового преобразователя
void ADC_Init(void)
{
  // Включение тактирования АЦП
  MDR_RST_CLK->PER_CLOCK |= (1 << RST_CLK_PCLK_ADC_Pos);

  // Деинициализация АЦП
  ADC_Reset();

  // Конфигурация порта для работы АЦП
  ADC_PortCfg();

  // Конфигурация АЦП
  MDR_ADC->ADC1_CFG = (1 << ADC1_CFG_REG_ADON_Pos)     // Работа АЦП (включен)
                    | (0 << ADC1_CFG_REG_CLKS_Pos)     // Источник тактирования АЦП (CPU)
                    | (0 << ADC1_CFG_REG_SAMPLE_Pos)   // Способ запуска АЦП (однократный)
                    | (5 << ADC1_CFG_REG_CHS_Pos)      // Целевой канал преобразователя (ADC5)
                    | (0 << ADC1_CFG_REG_CHCH_Pos)     // Режим последовательного переключения каналов (отключен)
                    | (0 << ADC1_CFG_REG_RNGC_Pos)     // Контроль границ преобразования (отключен)
                    | (0 << ADC1_CFG_M_REF_Pos)        // Источник опорного напряжения (внутренний)
                    | (11 << ADC1_CFG_REG_DIVCLK_Pos)  // Делитель тактовой частоты АЦП (2^11 = 2048)
                    | (0 << ADC1_CFG_SYNC_CONVER_Pos)  // Режим запуска двух АЦП (независимый)

  // ...Конфигурация датчика температуры и внутреннего источника напряжения 1.23 В
                    | (0 << ADC1_CFG_TS_EN_Pos)        // Работа блока датчика температуры и внутреннего источника напряжения 1.23 В (отключен)
                    | (0 << ADC1_CFG_TS_BUF_EN_Pos)    // Работа усилителя для датчика температуры и внутреннего источника напряжения 1.23 В (отключен)
                    | (0 << ADC1_CFG_SEL_TS_Pos)       // Преобразование сигнала с датчика температуры (отключено)
                    | (0 << ADC1_CFG_SEL_VREF_Pos)     // Преобразование сигнала с внутреннего источника напряжения 1.23 В (отключено)
                    | (0 << ADC1_CFG_TR_Pos)           // Подстройка напряжения внутреннего источника 1.23 В

  // ...Настройка задержек при преобразовании
                    | (0 << ADC1_CFG_DELAY_GO_Pos)     // Дополнительная задержка при выборе канала для заряда внутренней емкости (1 такт ядра)
                    | (0 << ADC1_CFG_DELAY_ADC_Pos);   // Разность фаз между циклами преобразователей (не используется)

  // Настройка запросов на обработку прерываний от АЦП
  MDR_ADC->ADC1_STATUS = (1 << ADC_STATUS_ECOIF_IE_Pos);  // Завершение аналого-цифрового преобразования

  // Назначение приоритета прерывания от АЦП
  NVIC_SetPriority(ADC_IRQn, 1);

  // Разрешение обработки прерывания от АЦП
  NVIC_EnableIRQ(ADC_IRQn);
}

// Поток аналого-цифровых преобразований
void Thread_ADC(void *argument)
{
  uint16_t digit;             // Значение аналого-цифрового преобразования
  float voltage;              // Вычисленное значение напряжения
  char message[LCD_STR_LEN];  // Сообщение, отображаемое на дисплей

  // Основной цикл
   while (1)
  {
    // Запуск процесса аналого-цифрового преобразования
    MDR_ADC->ADC1_CFG |= (1 << ADC1_CFG_REG_GO_Pos);

    // Ожидание окончания аналого-цифрового преобразования
    osMessageQueueGet(MsgQueId_ADC, &digit, NULL, osWaitForever);

    // Вычисление напряжения на основе результата преобразования
    voltage = VOLTAGE(digit);

    // Отображение результата измерения напряжения на дисплей
    snprintf(message, LCD_STR_LEN, "    V = %.3f В", voltage);
    LCD_PutString(message, 3);

    // Отображение результата аналого-цифрового преобразования на дисплей
    snprintf(message, LCD_STR_LEN, "    D = %u", digit);
    LCD_PutString(message, 5);

    // Задержка перед началом следующей итерации
    osDelay(250);
  }
}

// Обработчик аппаратного прерывания от АЦП
void ADC_IRQHandler(void)
{
  // Получение результата преобразования и сброс флага прерывания
  uint16_t digit = MDR_ADC->ADC1_RESULT & ADC_RESULT_Msk;

  // Отправление сообщения с результатом аналого-цифрового преобразования
  osMessageQueuePut(MsgQueId_ADC, &digit, osPriorityNormal, 0);
}
